<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>~</title>
        <link rel="stylesheet" href="css/floresta.css">
        <script src="js/phaser.min.js" charset="utf-8"></script>
        <script src="js/swipe.js" charset="utf-8"></script>
    </head>
    <body>
        <script type="text/javascript">
            var gameWidth = window.innerWidth;
            var gameHeight = window.innerHeight;
            var tileWidth = (gameHeight * 400) / 1080;
            var nTiles = Math.ceil(gameWidth / tileWidth);
            var game = new Phaser.Game(nTiles * 400, 1080, Phaser.AUTO, '', { preload: preload, create: create, update: update });
            var passageway = new Phaser.Rectangle(264, 134, 354, 216);
            var cursors, firstTile, lastTile, tiles, tile;

            var resizeGame = function () {
                gameWidth = window.innerWidth;
                gameHeight = window.innerHeight;
                tileWidth = (gameHeight * 400) / 1080;
                nTiles = Math.ceil(gameWidth / tileWidth);

                game.width = gameWidth;
                game.height = gameHeight;

                //game.stage.bounds.height = gameHeight;
                if (game.renderType === 1) {
                    game.renderer.resize(gameWidth, gameHeight);
                    Phaser.Canvas.setSmoothingEnabled(game.context, false);
                }
            }
            // window.onresize = resizeGame

            function preload() {
                for (i = 1; i < 25; i++) {
                    game.load.image('f'+i, 'img/f'+i+'.jpg');
                }
            }

            function create() {
                this.swipe = new Swipe(this.game);
                tiles = game.add.group();

                for (i = 1; i <= nTiles; i++) {
                    tiles.create(0 + (i-1)*400, 0, 'f'+i);
                }
                firstTile = 1;
                lastTile = nTiles;

                game.scale.pageAlignHorizontally = true;
                game.scale.pageAlignVertically = true;
                resizeGame();

                cursors = game.input.keyboard.createCursorKeys();
            }

            function update() {
                var direction = this.swipe.check();
                if (direction!==null) {
                    switch(direction.direction) {
                        case this.swipe.DIRECTION_LEFT:
                            moveTiles(true, 200);
                            break;
                        case this.swipe.DIRECTION_RIGHT:
                            moveTiles(false, 200);
                    }
                }

                if (cursors.right.isDown) {
                    moveTiles(true, 5);
                } else if (cursors.left.isDown) {
                    moveTiles(false, 5);
                }
            }

            function moveTiles(goRight, step) {
                var tilePositionX = 0;

                if (goRight) {
                    tilePositionX = tiles.getChildAt(tiles.length-1).x

                    if (tilePositionX < (nTiles-1)*400 + step) {
                        if (lastTile == 24)
                            return;
                        lastTile++;

                        tile = tiles.create(tilePositionX + 400, 0, 'f'+lastTile);

                        if (lastTile == 17) {
                            tile.inputEnabled = true;
                            tile.input.useHandCursor = true;
                            tile.events.onInputDown.add(onClick);
                        }
                    }

                    if (tiles.getChildAt(0).x < -400) {
                        tiles.removeChildAt(0);
                        firstTile++;
                    }

                    tiles.setAll('x', step, false, false, 2, false);
                }
                else {
                    tilePositionX = tiles.getChildAt(0).x

                    if (tilePositionX > -step) {
                        if (firstTile == 1)
                            return;
                        firstTile--;

                        tile = game.add.sprite(tilePositionX - 400, 0, 'f'+firstTile);
                        tiles.addAt(tile, 0);

                        if (firstTile == 17) {
                            tile.inputEnabled = true;
                            tile.input.useHandCursor = true;
                            tile.events.onInputDown.add(onClick);
                        }
                    }

                    if (tiles.getChildAt(tiles.length-1).x > (nTiles)*400) {
                        lastTile--;
                        tiles.removeChildAt(tiles.length-1);
                    }

                    tiles.setAll('x', step, false, false, 1, false);
                }
            }

            function onClick(sprite, pointer) {
                if (pointer.rightButton.isDown) {
                  return;
                }

                if (passageway.contains(pointer.x - sprite.position.x + 400, pointer.y)) {
                  window.location.href = "entrada.html";
                }
            }
        </script>
    </body>
</html>
